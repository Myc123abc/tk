#version 460
#extension GL_EXT_shader_image_load_formatted : require

layout(push_constant) uniform PushConstant
{
  vec2 window_extent;
} pc;

vec4 smaa_rt_metrics = vec4(1.0 / pc.window_extent, pc.window_extent);

#define SMAA_RT_METRICS smaa_rt_metrics
#define SMAA_GLSL_4     1
#define SMAA_INCLUDE_CS 1
#define SMAA_INCLUDE_PS 0
#define SMAA_INCLUDE_VS 0

// FIXME: currently, not flip, maybe lead wrong image

// edge detection mode
// 0 color edge detection
// 1 luma edge detection
// 2 depth edge detection
#ifndef EDGEMETHOD
#define EDGEMETHOD 0
#endif

layout(set = 0, binding = 1) uniform sampler LinearSampler;
layout(set = 0, binding = 2) uniform sampler PointSampler;

#include "SMAA.h"

// TODO: why is 8
#define SMAA_EDGES_COMPUTE_GROUP_X 8
#define SMAA_EDGES_COMPUTE_GROUP_Y 8
layout(local_size_x = SMAA_EDGES_COMPUTE_GROUP_X, local_size_y = SMAA_EDGES_COMPUTE_GROUP_Y) in;

#if EDGEMETHOD == 2
layout(set = 0, binding = 3) uniform SMAATexture2D(depthTex);
#else
layout(set = 0, binding = 3) uniform SMAATexture2D(colorTex);
#endif

// TODO: how to use it
#if SMAA_PREDICATION
layout(set = 0, binding = 4) uniform SMAATexture2D(predicationTex);
#endif

layout(set = 0, binding = 5) uniform writeonly image2D outputImage;

void main(void)
{
  // TODO: rearrange invocations for better cache locality
  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  // don't write outside image in case its size is not exactly divisible by group size
  if (coord.x < smaa_rt_metrics.z && coord.y < smaa_rt_metrics.w) 
  {
#if EDGEMETHOD == 0
  #if SMAA_PREDICATION
    SMAAColorEdgeDetectionCS(coord, outputImage, colorTex, predicationTex);
  #else
    SMAAColorEdgeDetectionCS(coord, outputImage, colorTex);
  #endif
#elif EDGEMETHOD == 1
  #if SMAA_PREDICATION
    SMAALumaEdgeDetectionCS(coord, outputImage, colorTex, predicationTex);
  #else
    SMAALumaEdgeDetectionCS(coord, outputImage, colorTex);
  #endif
#elif EDGEMETHOD == 2
    SMAADepthEdgeDetectionCS(coord, outputImage, depthTex);
#else
  #error Unknow Edge Mode
#endif
  }
}